# -*- coding: utf-8 -*-
"""FDExpressions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TMq1tEC0TFNerLmIMwvqgRX8EfyY5M3D
"""

using Pkg
# Pkg.Registry.add(RegistrySpec(url="https://github.com/ClimFlows/JuliaRegistry.git"))
# Pkg.add(["Adapt", "KernelAbstractions", "ManagedLoops", "LoopManagers", "NetCDF", "ClimFlowsData", "CFDomains"])
Pkg.add(["KernelAbstractions"])

using Adapt, KernelAbstractions

# @title Constructions of symbolic stencil expressions

# On a staggered mesh we must keep track of the position of each field relative to a reference
# step is the divisor, i.e. (step, pos) = (2, (0,1)) means a position (0, 1/2)
normalized(step, (a,b)::Tuple{Int,Int}) = (mod(a, step), mod(b, step))

abstract type FieldExpr{step, pos} end

const Ints{N} = NTuple{N, Int}

struct NameExpr{step, pos, name} <: FieldExpr{step, pos} end
function Base.show(io::IO, ::NameExpr{step, pos, name}) where {step, pos, name}
  print(io,"field($step, $pos, :$name)")
end

name_expr(step::Int, pos::Ints, name::Symbol) = NameExpr{step, normalized(step, pos), name}()

# Constructions of complex expressions from simple expressions
# Expressions are trees. Their leaves are `NameExpr` and their nodes are `GetIndexExpr` and `ApplyExpr`.

struct GetIndexExpr{step, pos, offset, Expr<:FieldExpr{step}} <: FieldExpr{step, pos}
  expr :: Expr
end

struct ApplyExpr{step, pos, Op, Args<:Tuple} <: FieldExpr{step, pos}
  op::Op
  args::Args
end

function Base.getindex(expr::FieldExpr{step, pos}, offset...) where {step, pos}
  new_pos = map((a,b)->mod(a-b, step), pos, offset) # if y[i]=x[i+1], then pos(y) = pos(x)+1
  GetIndexExpr{step, new_pos, offset, typeof(expr)}(expr)
end

# we can combine expressions only if they have the same step and pos
Base.:(-)(a::FieldExpr{step,pos}, b::FieldExpr{step,pos}) where {step, pos} = apply_expr(-, (a,b))
Base.:(+)(a::FieldExpr{step,pos}, b::FieldExpr{step,pos}) where {step, pos} = apply_expr(+, (a,b))
apply_expr(op, args::Tuple{Vararg{FieldExpr{step,pos}}}) where {step, pos} = ApplyExpr{step, pos, typeof(op), typeof(args)}(op, args)

# @title Evaluation of stencil expressions
using Base: @propagate_inbounds as @prop

(expr::FieldExpr)(data) = Frozen{typeof(expr), typeof(data)}(expr, data)
struct Frozen{Expr, Data} # Expr<:FieldExpr
  expr::Expr
  data::Data
end
@prop function Base.getindex(f::Frozen{<:FieldExpr{step, pos}}, indices...) where {step, pos}
  evaluate(f.expr, Shifts{pos}(), f.data, indices)
end

struct Shifts{shifts} end
@inline zero_shifts(indices::Tuple{Vararg{Int}}) = Shifts{map(zero, indices)}()

@prop evaluate(expr::ApplyExpr, shifts::Shifts, data, indices) = eval_map(expr.op, expr.args, shifts, data, indices)
@prop eval_map(op, (a,)::Tuple{<:Any}, shifts::Shifts, data, indices) = op(evaluate(a, shifts, data, indices))
@prop eval_map(op, (a,b)::Tuple{<:Any, <:Any}, shifts::Shifts, data, indices) = op(evaluate(a, shifts, data, indices), evaluate(b, shifts, data, indices))

@prop function evaluate(expr::GetIndexExpr{<:Any, pos, offsets}, ::Shifts{shifts}, data, indices) where {pos, offsets, shifts}
  new_shifts = map(+, offsets, shifts) # compile-time constants
  ## @info "evaluate GetIndexExpr" expr.expr offsets shifts new_shifts
  evaluate(expr.expr, Shifts{new_shifts}(), data, indices)
end

@inline function shifted(step::Int, (a,b)::Tuple{Int,Int}, (i,j)::Tuple{<:Any,<:Any})
  @assert a%step == 0 # evaluated at compile time
  @assert b%step == 0 # => optimized out when true
  ii , jj = i+div(a,step), j+div(b,step)
  return ii, jj
end

@prop function evaluate(expr::NameExpr{step, pos, name}, ::Shifts{shifts}, data, indices) where {step, pos, name, shifts}
  new_shifts = map(-, shifts, pos) # compile-time constants
  ## @info "evaluate NameExpr" name pos shifts new_shifts
  inds = shifted(step, new_shifts, indices)
  ## @info "evaluate NameExpr" name pos shifts new_shifts indices inds
  getindex(getproperty(data, name), inds...)
end

# @title Example: flux divergence

field(pos, name) = name_expr(2, pos, name) # staggered mesh => step=2
pos_h, pos_ux, pos_uy, pos_z = (0,0), (1,0), (0,1), (1,1)
ux, uy = field(pos_ux, :ux), field(pos_uy, :uy)

ddx(u) = u[1,0]-u[-1,0]
ddy(u) = u[0,1]-u[0,-1]
divu = ddx(ux) + ddy(uy)

M, N = 100, 200 # @param
p=10 # @param

arr() = randn(Float32, M, N)
state = (ux=arr(), uy=arr(), Phi=arr())
divu_view = divu(state) # expression + data => array-like object

f(u) = @inbounds u[2,2]
## @code_native debuginfo=:none f(divu_array)
## @code_typed optimize=true f(divu_array)

function g(x,y)
  @inbounds for i in axes(x,1), j in axes(x,2)
    x[i,j] = y[i,j]
  end
  return x
end

divu_array = arr()
g(divu_array, divu_view)
@info divu_array
@code_native debuginfo=:none g(divu_array, divu_view)

